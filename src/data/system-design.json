{
  "id": "system-design",
  "title": "System Design",
  "sections": [
    {
      "id": "in-a-hurry",
      "title": "In a Hurry",
      "topics": [
        {
          "id": "introduction",
          "title": "Introduction",
          "route": "/learn/system-design/in-a-hurry/introduction",
          "contentBlocks": [
            { "type": "heading", "text": "What is System Design?" },
            {
              "type": "text",
              "text": "System design is the process of defining the architecture, components, modules, interfaces, and data flows of a large-scale system. It ensures the system remains scalable, reliable, maintainable, and cost-efficient."
            },
            {
              "type": "image",
              "src": "https://images.unsplash.com/photo-1760696156441-676ffca4dfbd?q=80&w=865&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D",
              "alt": "system design architecture"
            },
            { "type": "heading", "text": "Why System Design is Important?" },
            {
              "type": "list",
              "items": [
                "Helps systems handle millions of users",
                "Improves reliability & availability",
                "Optimizes performance and cost",
                "Used heavily in tech interviews"
              ]
            }
          ]
        },

        {
          "id": "scalability",
          "title": "Scalability Basics",
          "route": "/learn/system-design/in-a-hurry/scalability",
          "contentBlocks": [
            { "type": "heading", "text": "What is Scalability?" },
            {
              "type": "text",
              "text": "Scalability means the system can handle increasing load by adding resources. A scalable system ensures consistent performance even during traffic spikes."
            },
            {
              "type": "image",
              "src": "https://images.unsplash.com/photo-1713325802293-d80963de0d90?w=600&auto=format&fit=crop&q=60&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxmZWF0dXJlZC1waG90b3MtZmVlZHwxMzh8fHxlbnwwfHx8fHw%3D",
              "alt": "scalability diagram"
            },
            { "type": "heading", "text": "Types of Scalability" },
            {
              "type": "list",
              
              "items": [
                "Vertical Scaling (Scale Up)",
                "Horizontal Scaling (Scale Out)",
                "Diagonal Scaling"
              ],
              "src": "https://images.unsplash.com/photo-1713325802293-d80963de0d90?w=600&auto=format&fit=crop&q=60&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxmZWF0dXJlZC1waG90b3MtZmVlZHwxMzh8fHxlbnwwfHx8fHw%3D",
              "alt": "scalability diagram"
            },
            { "type": "heading", "text": "Horizontal Scaling Example" },
            {
              "type": "text",
              "text": "Adding more servers behind a load balancer to distribute user traffic evenly is a classic example of horizontal scaling."
            }
          ]
        },

        {
          "id": "load-balancing",
          "title": "Load Balancing",
          "route": "/learn/system-design/in-a-hurry/load-balancing",
          "contentBlocks": [
            { "type": "heading", "text": "What is Load Balancing?" },
            {
              "type": "text",
              "text": "Load balancing distributes incoming network traffic across multiple servers to ensure no single server gets overloaded."
            },
            {
              "type": "image",
              "src": "https://source.unsplash.com/random/800x400?load-balancer",
              "alt": "load balancer"
            },
            { "type": "heading", "text": "Types of Load Balancers" },
            {
              "type": "list",
              "items": [
                "Layer 4 Load Balancers",
                "Layer 7 Load Balancers",
                "Global Server Load Balancers (GSLB)"
              ]
            },
            { "type": "heading", "text": "Popular Algorithms" },
            {
              "type": "list",
              "items": ["Round Robin", "Least Connections", "IP Hashing", "Weighted Distribution"]
            }
          ]
        },

        {
          "id": "caching",
          "title": "Caching",
          "route": "/learn/system-design/in-a-hurry/caching",
          "contentBlocks": [
            { "type": "heading", "text": "Why Caching?" },
            {
              "type": "text",
              "text": "Caching stores frequently accessed data in fast storage like RAM, reducing latency and database load."
            },
            {
              "type": "image",
              "src": "https://source.unsplash.com/random/800x400?cache",
              "alt": "cache memory"
            },
            { "type": "heading", "text": "Where Do We Use Caching?" },
            {
              "type": "list",
              "items": [
                "CDNs for static content",
                "Database query caching",
                "Session caching",
                "API response caching"
              ]
            },
            { "type": "heading", "text": "Cache Invalidation Strategies" },
            {
              "type": "list",
              "items": ["Write-through", "Write-back", "Write-around", "TTL-based eviction"]
            }
          ]
        },

        {
          "id": "database",
          "title": "Database Design",
          "route": "/learn/system-design/in-a-hurry/database",
          "contentBlocks": [
            { "type": "heading", "text": "SQL vs NoSQL" },
            {
              "type": "text",
              "text": "SQL databases provide ACID guarantees, while NoSQL databases provide high horizontal scalability and flexibility."
            },
            {
              "type": "image",
              "src": "https://source.unsplash.com/random/800x400?database",
              "alt": "database system"
            },
            { "type": "heading", "text": "Sharding" },
            {
              "type": "text",
              "text": "Sharding splits data across multiple machines to improve performance and storage capacity."
            },
            { "type": "heading", "text": "Replication" },
            {
              "type": "list",
              "items": ["Master-Slave", "Master-Master", "Read Replicas"]
            }
          ]
        },

        {
          "id": "queues",
          "title": "Message Queues",
          "route": "/learn/system-design/in-a-hurry/queues",
          "contentBlocks": [
            { "type": "heading", "text": "Why Use Message Queues?" },
            {
              "type": "text",
              "text": "Message queues allow asynchronous communication between services, improving reliability and decoupling."
            },
            {
              "type": "image",
              "src": "https://source.unsplash.com/random/800x400?queue",
              "alt": "message queue"
            },
            { "type": "heading", "text": "Popular MQ Systems" },
            {
              "type": "list",
              "items": ["Kafka", "RabbitMQ", "AWS SQS", "Google Pub/Sub"]
            },
            { "type": "heading", "text": "Use Cases" },
            {
              "type": "list",
              "items": [
                "Order Processing",
                "Notification Systems",
                "Log Processing",
                "Video Processing Pipelines"
              ]
            }
          ]
        }
      ]
    },
    {
  "id": "api-design",
  "title": "API Design",
  "topics": [
    {
      "id": "rest-basics",
      "title": "REST API Basics",
      "route": "/learn/system-design/api-design/rest-basics",
      "contentBlocks": [
        { "type": "heading", "text": "What is REST API?" },
        {
          "type": "text",
          "text": "REST (Representational State Transfer) is an architectural style for designing networked applications. It treats server objects as resources that can be created, read, updated, or deleted using stateless HTTP operations. REST emphasizes a uniform interface and separation between client and server which helps decouple implementations and evolve them independently."
        },
        {
          "type": "text",
          "text": "Key REST constraints include: statelessness (each request contains all context), cacheability (responses indicate cacheability), a uniform interface (standard verbs and resource-oriented URIs), and layered system (intermediaries like proxies and gateways). Following these constraints leads to simpler, scalable systems."
        },
        {
          "type": "image",
          "src": "https://source.unsplash.com/random/800x400?api,rest",
          "alt": "rest api design"
        },
        { "type": "heading", "text": "Practical REST Example" },
{
  "type": "content",
  "heading": "Scalability Example",
  "text": "Horizontal scaling means adding more servers.",
  "image": {
    "src": "https://images.unsplash.com/photo-1713325802293-d80963de0d90",
    "alt": "scaling"
  },
  "list": [
    "Add more servers",
    "Use load balancer",
    "Distribute traffic"
  ],
  "code": [
    {
      "language": "javascript",
      "content": "console.log('Horizontal Scaling');"
    },
    {
      "language": "bash",
      "content": "pm2 scale app 4"
    }
  ]
}

      ]
    },

    {
      "id": "best-practices",
      "title": "API Design Best Practices",
      "route": "/learn/system-design/api-design/best-practices",
      "contentBlocks": [
        { "type": "heading", "text": "Designing a Good API" },
        {
          "type": "text",
          "text": "A good API is consistent, discoverable, versioned, and secure. It focuses on developer experience (DX): clear naming, consistent error handling, helpful documentation, and predictable semantics. Think of your API as a product for other engineers."
        },
        {
          "type": "image",
          "src": "https://source.unsplash.com/random/800x400?design,api",
          "alt": "api best practices"
        },
        { "type": "heading", "text": "Concrete Best Practices" },
        {
          "type": "list",
          "items": [
            "Design around resources (nouns) rather than RPC verbs: /users/{id}/orders not /getUserOrders",
            "Use consistent naming and pluralization (/users vs /user)",
            "Return proper HTTP status codes and helpful error messages (see Error Handling)",
            "Document endpoints, request/response schemas, and examples with OpenAPI/Swagger",
            "Version your API early (URI version, request header, or content negotiation)",
            "Support pagination, sorting, and filtering for list endpoints",
            "Design for backward compatibility where possible (additive changes only)",
            "Avoid overloading endpoints with many responsibilities (single responsibility principle)"
          ]
        },
        {
          "type": "text",
          "text": "When evolving an API, prefer additive changes (new fields, new endpoints) and deprecate carefully. Communicate breaking changes and provide migration guides."
        }
      ]
    },

    {
      "id": "http-status",
      "title": "HTTP Status Codes & Error Handling",
      "route": "/learn/system-design/api-design/http-status",
      "contentBlocks": [
        { "type": "heading", "text": "Why Proper Status Codes Matter" },
        {
          "type": "text",
          "text": "HTTP status codes help clients programmatically handle responses. Using correct codes reduces ambiguity and improves client-side error handling, retries, and UX."
        },
        {
          "type": "image",
          "src": "https://source.unsplash.com/random/800x400?http,status",
          "alt": "http status codes"
        },
        { "type": "heading", "text": "Common Status Codes and Usage" },
        {
          "type": "list",
          "items": [
            "200 OK – Successful GET/PUT/PATCH/DELETE (returns resource or confirmation)",
            "201 Created – Successful POST that created a resource (include Location header)",
            "204 No Content – Success with no response body (useful for DELETE)",
            "400 Bad Request – Client sent invalid input/format",
            "401 Unauthorized – Authentication required or failed",
            "403 Forbidden – Authenticated but not allowed to perform action",
            "404 Not Found – Resource does not exist",
            "409 Conflict – Conflicting request (e.g., duplicate unique field)",
            "422 Unprocessable Entity – Validation errors with details",
            "429 Too Many Requests – Client exceeded rate limits",
            "500 / 502 / 503 – Server/Upstream errors; include retry guidance"
          ]
        },
        {
          "type": "text",
          "text": "Error payloads should be structured (e.g., { code, message, details }) and include a human-readable message and a machine-readable error code for clients to react reliably. Example: {\"error\": {\"code\": \"USER_NOT_FOUND\", \"message\": \"User with id 123 not found\"}}."
        }
      ]
    },

    {
      "id": "auth-patterns",
      "title": "Authentication & Authorization Patterns",
      "route": "/learn/system-design/api-design/auth-patterns",
      "contentBlocks": [
        { "type": "heading", "text": "Auth vs Authz" },
        {
          "type": "text",
          "text": "Authentication (AuthN) verifies identity (who you are). Authorization (AuthZ) checks permissions (what you can do). Both are critical for secure APIs and should be designed separately but integrated effectively."
        },
        {
          "type": "image",
          "src": "https://source.unsplash.com/random/800x400?security,authentication",
          "alt": "authentication patterns"
        },
        { "type": "heading", "text": "Common Authentication Methods" },
        {
          "type": "list",
          "items": [
            "API Keys – simple, for service-to-service or low-risk apps (rotate regularly)",
            "JWT (JSON Web Tokens) – stateless tokens carrying claims; use short TTLs and rotation to reduce risk",
            "OAuth 2.0 – delegation for third-party access (Authorization Code flow for web apps)",
            "mTLS – mutual TLS for strong service-to-service authentication",
            "Session-based – server-side sessions with cookies (useful for browser clients)"
          ]
        },
        { "type": "heading", "text": "Authorization Approaches" },
        {
          "type": "list",
          "items": [
            "Role-based Access Control (RBAC) – roles map to permissions (simple and common)",
            "Attribute-based Access Control (ABAC) – flexible policies based on attributes and conditions",
            "Permission checks at service boundary – validate on the API gateway or service itself",
            "Principle of least privilege – grant minimum required permissions"
          ]
        },
        {
          "type": "text",
          "text": "Practical tips: never store sensitive secrets in tokens, always validate tokens on the server, and implement token revocation or short lifetimes with refresh tokens."
        }
      ]
    },

    {
      "id": "versioning-pagination",
      "title": "Versioning, Pagination & Filtering",
      "route": "/learn/system-design/api-design/versioning-pagination",
      "contentBlocks": [
        { "type": "heading", "text": "Why Versioning Matters" },
        {
          "type": "text",
          "text": "Versioning allows APIs to evolve without breaking existing clients. Plan a versioning strategy early to avoid breaking changes and maintain developer trust."
        },
        {
          "type": "image",
          "src": "https://source.unsplash.com/random/800x400?versioning,api",
          "alt": "api versioning"
        },
        { "type": "heading", "text": "Versioning Strategies" },
        {
          "type": "list",
          "items": [
            "URI versioning: /v1/posts – simple and visible",
            "Header versioning: Accept: application/vnd.myapp.v1+json – keeps URIs clean",
            "Query param: ?version=1 – less common, can be noisy",
            "Semantic versioning for SDKs and client libraries"
          ]
        },
        { "type": "heading", "text": "Pagination & Filtering Patterns" },
        {
          "type": "text",
          "text": "For list endpoints, avoid returning huge result sets. Use pagination patterns such as offset-based (page & limit) or cursor-based (recommended for large or changing datasets). Provide filtering and sorting via query parameters and document limits and defaults clearly."
        },
        {
          "type": "list",
          "items": [
            "Offset pagination: ?page=2&limit=50 (simple)",
            "Cursor pagination: ?after=cursorValue (stable for real-time datasets)",
            "Filtering: ?status=active&category=payments",
            "Sorting: ?sort=created_at:desc"
          ]
        }
      ]
    },

    {
      "id": "operational-considerations",
      "title": "Operational Concerns: Caching, Rate Limiting & Monitoring",
      "route": "/learn/system-design/api-design/operational-considerations",
      "contentBlocks": [
        { "type": "heading", "text": "Operational Patterns for Stable APIs" },
        {
          "type": "text",
          "text": "Beyond design, APIs require operational controls: caching to reduce latency and load, rate limiting to protect services, and monitoring to detect issues early. These concerns are often enforced at API gateways or edge proxies."
        },
        {
          "type": "image",
          "src": "https://source.unsplash.com/random/800x400?monitoring,api",
          "alt": "api operations"
        },
        { "type": "heading", "text": "Caching Strategies" },
        {
          "type": "list",
          "items": [
            "HTTP caching with Cache-Control headers (public/private, max-age, stale-while-revalidate)",
            "Edge caching (CDN) for static or cacheable responses",
            "Server-side caches (Redis) for expensive DB queries",
            "Cache invalidation policies (time-based TTL, versioning of resources)"
          ]
        },
        { "type": "heading", "text": "Rate Limiting & Throttling" },
        {
          "type": "text",
          "text": "Protect APIs against abuse using rate limiting by IP, user, or API key. Use throttling or leaky-bucket algorithms and provide clear 'Retry-After' headers for clients."
        },
        {
          "type": "heading",
          "text": "Monitoring & SLA"
        },
        {
          "type": "list",
          "items": [
            "Collect metrics: latency (p95/p99), error rates, throughput",
            "Use distributed tracing (OpenTelemetry) for request flows across services",
            "Alert on SLA breaches and high error rates",
            "Provide status pages and SLAs for consumers"
          ]
        }
      ]
    }
  ]
    },
    {
  "id": "microservices",
  "title": "Microservices",
  "topics": [
    {
      "id": "intro",
      "title": "Microservices Overview",
      "route": "/learn/system-design/microservices/intro",
      "contentBlocks": [
        { "type": "heading", "text": "What Are Microservices?" },
        {
          "type": "text",
          "text": "Microservices are an architectural approach that breaks a monolithic application into small, independently deployable services. Each service owns a single business capability and has its own codebase, datastore (optional), and lifecycle."
        },
        {
          "type": "text",
          "text": "This approach improves team autonomy, deployment speed, and scalability. However, it introduces distributed system challenges like network latency, data consistency, and operational complexity."
        },
        {
          "type": "image",
          "src": "https://source.unsplash.com/random/800x400?microservices,architecture",
          "alt": "microservices architecture"
        },
        { "type": "heading", "text": "When to Choose Microservices" },
        {
          "type": "list",
          "items": [
            "When the product has multiple teams and bounded contexts",
            "When deployment velocity and independent scaling are important",
            "When different modules need different tech stacks",
            "Avoid microservices for small/simple apps — complexity can outweigh benefits"
          ]
        }
      ]
    },

    {
      "id": "communication-patterns",
      "title": "Communication Patterns",
      "route": "/learn/system-design/microservices/communication-patterns",
      "contentBlocks": [
        { "type": "heading", "text": "Synchronous vs Asynchronous" },
        {
          "type": "text",
          "text": "Microservices communicate using synchronous (HTTP/REST, gRPC) or asynchronous (message queues, event streams) patterns. Synchronous calls are simple but create tighter coupling and propagate latency; asynchronous calls improve resilience and decoupling but add eventual consistency and complexity."
        },
        {
          "type": "image",
          "src": "https://source.unsplash.com/random/800x400?communication,services",
          "alt": "service communication"
        },
        { "type": "heading", "text": "Patterns & Use Cases" },
        {
          "type": "list",
          "items": [
            "Request-Response (REST/gRPC) — good for UI-to-service interactions requiring immediate response",
            "Pub/Sub (Kafka, Pub/Sub) — broadcast events to many consumers (loose coupling)",
            "Work Queues — background processing of heavy tasks (image processing, emails)",
            "Event Sourcing — store changes (events) as the source of truth for auditability",
            "CQRS (Command Query Responsibility Segregation) — separate read/tailored read models from write models"
          ]
        },
        {
          "type": "text",
          "text": "Design tip: prefer asynchronous patterns for non-blocking operations (notifications, analytics), and use timeouts and circuit breakers for synchronous calls to avoid cascading failures."
        }
      ]
    },

    {
      "id": "service-discovery",
      "title": "Service Discovery & API Gateways",
      "route": "/learn/system-design/microservices/service-discovery",
      "contentBlocks": [
        { "type": "heading", "text": "Why Service Discovery?" },
        {
          "type": "text",
          "text": "In dynamic environments (containers, autoscaling), service instances appear and disappear. Service discovery keeps track of available instances and enables clients to reach services reliably."
        },
        {
          "type": "image",
          "src": "https://source.unsplash.com/random/800x400?discovery,kubernetes",
          "alt": "service discovery"
        },
        { "type": "heading", "text": "Discovery Mechanisms" },
        {
          "type": "list",
          "items": [
            "Client-side discovery: client queries a registry (Eureka/Consul) and load-balances across instances",
            "Server-side discovery: clients call a load balancer or API gateway that forwards requests to healthy instances",
            "DNS-based discovery: use DNS entries updated by orchestration platforms (Kubernetes services)"
          ]
        },
        { "type": "heading", "text": "API Gateway Role" },
        {
          "type": "text",
          "text": "An API Gateway acts as a facade for clients: authentication, rate-limiting, request routing, protocol translation (e.g., REST to gRPC), and response aggregation. Gateways simplify client interactions and centralize cross-cutting concerns."
        }
      ]
    },

    {
      "id": "fault-tolerance",
      "title": "Fault Tolerance & Resilience",
      "route": "/learn/system-design/microservices/fault-tolerance",
      "contentBlocks": [
        { "type": "heading", "text": "Building Resilient Services" },
        {
          "type": "text",
          "text": "Resilience means the system continues to operate under partial failures. Since microservices are distributed, failures are inevitable — design patterns exist to contain and recover from them."
        },
        {
          "type": "image",
          "src": "https://source.unsplash.com/random/800x400?resilience,system",
          "alt": "resilience and fault tolerance"
        },
        { "type": "heading", "text": "Common Patterns" },
        {
          "type": "list",
          "items": [
            "Circuit Breaker – stop calling an unhealthy downstream service temporarily",
            "Retries with Exponential Backoff – reattempt transient errors carefully to avoid overload",
            "Bulkheads – isolate resources so a failure in one area doesn't take down others",
            "Timeouts – set reasonable timeouts for remote calls to avoid thread exhaustion",
            "Graceful Degradation – offer reduced functionality when dependencies fail"
          ]
        },
        {
          "type": "text",
          "text": "Monitoring health endpoints and automated failover strategies (e.g., blue/green deployments) are also essential for operational resilience."
        }
      ]
    },

    {
      "id": "data-management",
      "title": "Data Management & Consistency",
      "route": "/learn/system-design/microservices/data-management",
      "contentBlocks": [
        { "type": "heading", "text": "Challenges of Data in Microservices" },
        {
          "type": "text",
          "text": "Microservices often own separate data stores to avoid tight coupling. This creates challenges in maintaining consistency across services for transactions that span multiple services."
        },
        {
          "type": "image",
          "src": "https://source.unsplash.com/random/800x400?database,distributed",
          "alt": "distributed data"
        },
        { "type": "heading", "text": "Strategies for Consistency" },
        {
          "type": "list",
          "items": [
            "Two-phase commit (2PC) – strong consistency but complex and blocking; rarely used across services at scale",
            "Sagas – sequence of local transactions with compensating actions on failure (choreography vs orchestration)",
            "Eventual Consistency – accept temporary inconsistencies with convergence guarantees via events",
            "Materialized views & CQRS – maintain read-optimized copies for fast queries"
          ]
        },
        {
          "type": "text",
          "text": "Choose the pattern based on domain needs: financial transactions may need stronger guarantees; user activity or analytics can often tolerate eventual consistency."
        }
      ]
    }
  ]
}
  ]
}
